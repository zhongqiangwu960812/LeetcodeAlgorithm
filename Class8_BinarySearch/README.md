# 知识点梳理

## 二分搜索算法

二分搜索算法看似简单，写对很难，而且变形很多。所以最容易被拿来在面试中考察大家写 code 的能力。

二分搜索（折半搜索）是一种在**有序数组**中查找某一特定元素的搜索算法。从定义可知，**运用二分搜索的前提是数组必须是排好序的**。另外，输入并不一定是数组，也有可能是给定一个区间的起始和终止的位置。

* 优点： 时间复杂度是$O(logn)$, 非常高效
* 缺点：要求待查找的数组或者区间是排好序的

对数组进行动态的删除和插入操作并完成查找，平均复杂度会变为 $O(n)$。此时应当考虑采取自平衡的二叉查找树：

* 在 $O(nlogn)$ 的时间内用给定的数据构建出一棵二叉查找树；
* 在 $O(logn)$ 的时间里对目标数据进行搜索；
* 在 $O(logn)$ 的时间里完成删除和插入的操作。

因此，==当输入的数组或者区间是排好序的，同时又不会经常变动，而要求从里面找出一个满足条件的元素的时候，二分搜索就是最好的选择==。

二分查找的前提：

* 目标函数单调性（单调递增或者递减）
* 存在上下界
* 能够通过索引访问



二分搜索一般化的解题思路如下：

<img src="img/1.gif" style="zoom:30%;" />

1. 从已经排好序的数组或者区间中取出中间位置的元素， 判断该元素是否满足要搜索的条件， 如果满足， 停止搜索， 程序结束。
2. 如果正中间的元素不满足条件， 则从它两边的区域进行搜索。 由于数组是排好序的， 可以利用排除法， 确定接下来应该从这两边的哪一个进行搜索
3. 通过判断， 如果发现真正要找的元素在左半区间的话， 就继续在左半区间里进行二分搜索。 反之， 就在右半区间进行二分搜索。

递归解法： 优点简洁， 缺点： 执行消耗大。

通过一个例题， 看看二分搜索的递归模板和非递归模板。

> 假设我们要从一个排好序的数组里面{1, 3, 4, 6, 7, 8, 10, 13, 14}查看数字7是否在里面， 如果在返回下标， 否则，返回-1

递归写法的代码模板：

```python 
# 二分搜索函数的定义里， 除了要指定数组nums和目标查找数target之外， 还要指定查找区间的起点和终点位置， 分别用Low和high来指定
def binarySearch(nums, target, low, high):
	# 为了避免无限循环， 先判断，如果起点位置大于了终点位置， 表面这是一个非法区间，已经尝试了所有的搜索区间还是没找到结果，返回-1
    if low > high:
        return -1
    # 取正中间那个数的下标
    middle = low + (high-low) / 2
    
    # 判断中间那个数是不是target，如果是，返回下标
    if nums[middle] == target:
        return middle
    
    # 如果发现目标数在左边， 就递归的从左半边二分搜索, 否则从右边递归的二分搜索
    if target < nums[middle]:
        return binarySearch(nums, target, low, middle-1)
    else:
        return binarySearch(nums, target, middle+1, high)
```

注意：

* 在计算middle的时候， 不能简单的用`(low+high)/2`， 可能会导致溢出
* 在取左半边以及右半边的区间时， 左半边是`[low, middle-1]`, 右半边是`[middle+1, high]`， 这是两个闭区间， 因为已经确定了Middle那个点不是我们要找的，没有必要再加入左右
* 对于一个长度为奇数的数组， 比如`{1, 2, 3, 4, 5}`， 按照`low+(high-low) / 2` 来计算， middle就是正中间的那个位置， 对于长度为偶数的数组`{1, 2, 3, 4}`， middle是中间左边的一个位置

时间复杂度

> 假设我们要对长度为n的数组进行二分搜索， $T(n)$是执行函数， 我们可以得到$T(n)=T(n/2)+1$, 采用公式法可以得到时间复杂度是$O(logn)$

非递归解法模板：

```python
def binarySearch(nums, target, low, high):
	
	# while循环中， 判断搜索的空间是否有效
	while low <= high:
		
		# 正中间的下标
		middle = low + (high-low) / 2
		
        # 取正中间那个数的下标
		if nums[middle] == target:
			return middle
		# 如果发现目标数在左边，调整搜索区间的终点为 middle - 1；否则，调整搜索区间的起点为 middle + 1
		if target < nums[middle]:
			high = middle - 1
		else:
			low = middle + 1
	
	# 没找到
	return -1
```

核心步骤：

1. 确定搜索的范围和区间
2. 取中间的数判断是否满足条件
3. 如果不满足条件， 判断应该在哪个半边继续进行搜索

二分搜索看起来会比较简单， 但是变形很多， 一定要把握住核心， 然后通过做题来提高。具体的看相应的题目。

# 刷过的题目梳理



# 总结